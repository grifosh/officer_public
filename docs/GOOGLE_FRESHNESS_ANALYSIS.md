# Анализ актуальности изменений Google Calendar

## Как система определяет что Google Calendar содержит самые актуальные данные

### 1. Ключевые принципы определения актуальности

**Система использует временные метки для определения направления синхронизации:**

1. **Приоритет времени**: Более новое изменение всегда имеет приоритет
2. **Защита от конфликтов**: Одновременные изменения (< 5 сек) помечаются как конфликт
3. **Неизвестное время**: Если нет информации о времени изменения, используется доступная информация

### 2. Алгоритм определения актуальности

```
Есть ли событие в Google Calendar?
├─ НЕТ → local_to_google (создать в Google)
└─ ДА → Есть ли событие локально?
    ├─ НЕТ → google_to_local (создать локально)
    └─ ДА → Сравнить временные метки
        ├─ Нет локального времени → google_to_local
        ├─ Нет Google времени → local_to_google
        └─ Оба времени есть → Сравнить
            ├─ Разница < 1 сек → no_change
            ├─ Разница < 5 сек → conflict (одновременные изменения)
            ├─ local_updated > google_updated → local_to_google
            └─ google_updated > local_updated → google_to_local
```

### 3. Временные метки для анализа

**Локальная БД:**
- `last_local_update` - когда событие было изменено локально (через UI)
- `last_google_sync` - когда последний раз синхронизировались с Google
- `google_updated_at` - время последнего обновления в Google Calendar

**Google Calendar:**
- `updated` - время последнего изменения события в Google Calendar

### 4. Практические примеры

#### Пример 1: Google событие обновилось недавно
```
Локальное время: 2025-10-13 10:00:00
Google время:    2025-10-13T16:30:00.000Z
Разница:         23400 секунд (6.5 часов)
Результат:       google_to_local (Google новее на 23400.0с)
```

#### Пример 2: Локальное событие обновилось недавно
```
Локальное время: 2025-10-13 17:00:00
Google время:    2025-10-13T10:00:00.000Z
Разница:         25200 секунд (7 часов)
Результат:       local_to_google (локальное новее на 25200.0с)
```

#### Пример 3: Одновременные изменения (конфликт)
```
Локальное время: 2025-10-13 16:00:00
Google время:    2025-10-13T16:00:03.000Z
Разница:         3.0 секунд
Результат:       conflict (одновременные изменения)
```

#### Пример 4: Нет локального времени (наш случай)
```
Локальное время: None (событие создано через Google)
Google время:    2025-10-13T16:26:34.607Z
Результат:       google_to_local (Google событие изменено, локальное время неизвестно)
```

### 5. Классификация временных различий

| Разница во времени | Классификация | Действие |
|-------------------|---------------|----------|
| < 1 секунда | `no_change` | Изменений нет |
| 1-5 секунд | `conflict` | Одновременные изменения |
| > 5 секунд | `google_to_local` или `local_to_google` | Выбирается более новое |

### 6. Реальные сценарии использования

#### Сценарий 1: Пользователь обновил событие в Google Calendar
- **Описание**: Пользователь зашел в Google Calendar и изменил название события
- **Ожидаемый результат**: `google_to_local`
- **Фактический результат**: `google_to_local` ✅
- **Причина**: Google событие изменено, локальное время неизвестно

#### Сценарий 2: Пользователь обновил событие в локальном UI
- **Описание**: Пользователь изменил событие через веб-интерфейс приложения
- **Ожидаемый результат**: `local_to_google`
- **Фактический результат**: `local_to_google` ✅
- **Причина**: Локальное событие новее на 3600.0с

#### Сценарий 3: Одновременные изменения
- **Описание**: Пользователь изменил событие в Google Calendar, а кто-то другой - в локальном UI
- **Ожидаемый результат**: `conflict`
- **Фактический результат**: `conflict` ✅
- **Причина**: Одновременные изменения (разница: 2.0с)

#### Сценарий 4: Событие создано только в Google Calendar
- **Описание**: Новое событие создано в Google Calendar, его нет в локальной БД
- **Ожидаемый результат**: `google_to_local`
- **Фактический результат**: `google_to_local` ✅
- **Причина**: Google событие изменено, локальное время неизвестно

### 7. Ключевые индикаторы актуальности Google

**Система считает Google Calendar актуальным когда:**

1. **Нет локального времени обновления** (`last_local_update = null`)
2. **Google время новее локального** (разница > 5 секунд)
3. **Google обновилось после последней синхронизации**
4. **Событие существует только в Google Calendar**

### 8. Логика приоритетов при конфликтах

```python
def get_sync_priority(local_event, google_event):
    # Приоритеты:
    # 1. События с важными локальными данными (notes, questions)
    local_has_important_data = bool(
        local_event.get('notes') or 
        local_event.get('actual_open_questions') or
        local_event.get('recording_url')
    )
    
    # 2. События с Google ID (уже синхронизированные)
    has_google_id = bool(local_event.get('google_event_id'))
    
    # 3. Время последнего изменения
    if local_has_important_data:
        return 'local'
    elif has_google_id and google_updated > local_updated:
        return 'google'
    else:
        return 'local'  # По умолчанию приоритет локальным данным
```

### 9. Мониторинг актуальности

**Для отслеживания актуальности изменений система логирует:**

- Время последнего изменения в Google Calendar
- Время последнего локального изменения
- Время последней синхронизации
- Направление синхронизации и причину
- Разницу во времени между изменениями

### 10. Заключение

Система корректно определяет актуальность изменений Google Calendar на основе:

1. **Временных меток** - сравнивает время последних изменений
2. **Логики приоритетов** - учитывает важность локальных данных
3. **Защиты от конфликтов** - обрабатывает одновременные изменения
4. **Неизвестных состояний** - использует доступную информацию

Все протестированные сценарии работают корректно, что подтверждает надежность системы синхронизации.
